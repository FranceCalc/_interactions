<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
<entry key="node_file" type="xstring" value="settings.xml"/>
<config key="flow_stack"/>
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="sourceCode" type="xstring" value="import pandas as pd%%00010import networkx as nx%%00010import numpy as np%%00010%%00010%%00010# transfer matrix dataframe%%00010tr_df = pd.DataFrame()%%00010tr_df= input_table_1%%00010# conversion years to string%%00010tr_df['Years']=tr_df['Years'].astype(str)%%00010# multiindexing transfer matrix by years and trading zone%%00010# years and trading zones are left as columns for future calc.%%00010tr_df.set_index(['Years','Trading_zones'], drop=False, inplace=True)%%00010tr_df.sort_index()%%00010# NAN values to zeros%%00010tr_df.fillna(0, inplace=True)%%00010# calculation transfer capacities for yearly sum energy constraint %%00010# the result is converted to long integer for networl calc.%%00010tr_df.iloc[:,2:]=tr_df.iloc[:,2:].astype(np.int64)*8760%%00010%%00010## demand_supply gap dataframe%%00010with_trz = pd.DataFrame()%%00010with_trz = input_table_2%%00010with_trz['Years']=with_trz['Years'].astype(str)%%00010%%00010# multiindexing electricity demand_supply dataframe by years and trading zone%%00010# years and trading zones are left as columns for future calc.%%00010sd_gap=with_trz.groupby(['Years','Trade_zone']).mean()%%00010sd_gap['Years']=sd_gap.index.get_level_values(0)%%00010sd_gap['Trade_zone']=sd_gap.index.get_level_values(1)%%00010%%00010# NAN values to zeros%%00010sd_gap.fillna(0, inplace=True)%%00010# initialization of export import values%%00010sd_gap.loc[:,'I/O_gap_reduce']=0%%00010# convert gap (in MWh) to long integer for networl calc.%%00010gap_df=sd_gap.loc[:, ['gap_tz[MWh]']].astype(np.int64)%%00010%%00010%%00010#determination exporer and importer trading zones%%00010gap_df.loc[:, 'Trade_zone']=sd_gap.loc[:,'Trade_zone'].copy(deep=True)%%00010gap_export=gap_df[gap_df['gap_tz[MWh]']&lt;=0]%%00010gap_import=gap_df[gap_df['gap_tz[MWh]']&gt;0]%%00010%%00010# assign list of years for the loop bellow%%00010# years withou surplus / deficit are skipped%%00010# skipped years are handled later%%00010Years_all=['2020','2025','2030','2035','2040','2045','2050']%%00010years_export=set(gap_export.index.get_level_values(0).drop_duplicates())%%00010years_import=set(gap_import.index.get_level_values(0).drop_duplicates())%%00010Years_list=list(years_export.intersection(years_import))%%00010Years_skipped=list(set(Years_all).difference(years_export.intersection(years_import)))%%00010%%00010if set(Years_skipped)==set(Years_all):%%00010%%00009sd_gap['result_gap[TWh]']=sd_gap['gap_tz[MWh]']/1000000%%00009%%00010else:%%00010%%00009%%00009%%00010%%00009%%00009%%00010%%00009# Years_list=['2035']%%00010%%00010%%00009#assign trading zone names for loop bellow%%00010%%00009trz_list=list(tr_df['Trading_zones'].unique())[:-1]%%00010%%00009#%%00010%%00009# calculation in years%%00010%%00009#Years_list=['2045']%%00010%%00009for year in Years_list:%%00010%%00009%%00009%%00010%%00009%%00009# initialization of empty digraph%%00010%%00009%%00009# Their nodes will be the exporters/importers with their demands as metadata%%00010%%00009%%00009# and edges with capacities and weights as metadata%%00010%%00009%%00009gap_df_y=gap_df.loc[(year)].copy(deep=True)%%00010%%00009%%00009gap_df_y.loc[:,'I/O_gap_reduce']=0%%00010%%00010%%00009%%00009G = nx.DiGraph()%%00010%%00009%%00009%%00010%%00009%%00009# edges are defined by using transfer matrix yearly slice%%00010%%00009%%00009# both row_indexes and column names are the trading zones %%00010%%00009%%00009# rows contain the trading zones' export capacities%%00010%%00009%%00009# columns contain the trading zones' import capacities%%00010%%00009%%00009# foe each year necessary capacity data are assigned to dataframe 'tr_edges'     %%00010%%00009%%00009tr_edges=tr_df.loc[(year)][:-1]%%00010%%00009%%00009%%00010%%00009%%00009# list of exporter trading zones%%00010%%00009%%00009e_exp=list(gap_export.loc[(year)]['Trade_zone'])%%00010%%00009%%00009#list of imprter trading zones%%00010%%00009%%00009e_imp=list(gap_import.loc[(year)]['Trade_zone'])%%00010%%00009   %%00010%%00009%%00009# narrowing the transfer matrix (i. e. the bellow groph edges) to the %%00010%%00009%%00009# range of actual (yearly) exporter/importer members   %%00010%%00009%%00009tr_edges=tr_edges.loc[e_exp, e_imp]%%00010%%00009%%00009tr_edges_orig=tr_edges.copy()%%00010%%00010%%00009%%00010%%00009%%00009################################## STEP A #########################  %%00010%%00009%%00009# generating a dataframe which make it possible to create graph with its%%00010%%00009%%00009# nodes, edges and the edge metadata - it uses Python networkx modul%%00010%%00009%%00009%%00010%%00009%%00009# inserting trading zone names from dataframe index to the first column %%00010%%00009%%00009tr_edges.insert(0, 'Trade_zone', tr_edges.index)%%00010%%00009%%00009#tr_edges_orig.insert(0, 'Trade_zone', tr_edges_orig.index)%%00010%%00009%%00009# melting dataframe to get a from (exporter), to (importer), capacity, weight%%00010%%00009%%00009# structure weight is not used in this step but networkx algorithm needs this%%00010%%00009%%00009# argument%%00010%%00009%%00009tr_edges2=pd.melt(tr_edges, id_vars=['Trade_zone'], value_name='capacity')%%00010%%00009%%00009#tr_edges_orig=pd.melt(tr_edges_orig, id_vars=['Trade_zone'], value_name='capacity')%%00010%%00009%%00009# reducing dataframe to non_zero capacities%%00010%%00009%%00009tr_edges2=tr_edges2[tr_edges2['capacity']&gt;0]%%00010%%00009%%00009#filling up weights%%00010%%00009%%00009tr_edges2.sort_values(by=['capacity'], ascending=False, inplace=True)%%00010%%00010%%00009%%00009tr_edges2['weight']=[ii for ii in range(len(tr_edges2['capacity']))]%%00010%%00010%%00009%%00009# creating graph nodes and edges%%00010%%00009%%00009G=nx.from_pandas_edgelist(tr_edges2, 'Trade_zone', 'variable', edge_attr=['capacity', 'weight'], create_using=nx.DiGraph())%%00010%%00010%%00009   %%00010%%00009%%00009# The networkx algorith also need zero summed export/import demand%%00010%%00009%%00009# Therefore a virtual exporter/importer member (depending on the balance) %%00010%%00009%%00009# is created to ensure this condition%%00010%%00009%%00009%%00010%%00009%%00009# initial values of summerized export/import demnads %%00010%%00009%%00009sum_exp=gap_export.loc[year,'gap_tz[MWh]'].sum()%%00010%%00009%%00009sum_imp=gap_import.loc[year,'gap_tz[MWh]'].sum()%%00010%%00010%%00009%%00009%%00010%%00009%%00009 ################################## STEP B #########################%%00010%%00009%%00009# In case of large demands the capacities can be works as constraints%%00010%%00009%%00009# and the flow algorithm cannot handle it, so the export/import demands of %%00010%%00009%%00009# nodes (ie. trading zones) have to fit to the capacity constrains%%00010%%00009%%00009%%00010%%00009%%00009# As in step A gap constrains were built into edges as capacity constraints%%00010%%00009%%00009# in that case all of the constraints are handled%%00010%%00009%%00009%%00010%%00009%%00009# Nodes are reduced to the sum of the export capacities of this (export) node     %%00010%%00009%%00009for index, row in gap_export.loc[(year)].iterrows():%%00010%%00009%%00009%%00009G.add_node(row['Trade_zone'], demand =row['gap_tz[MWh]'])%%00009%%00009%%00010%%00009%%00009# Nodes are reduced to the sum of the import capacities of this (import) node  %%00010%%00009%%00009for index, row in gap_import.loc[(year)].iterrows():%%00010%%00009%%00009%%00009G.add_node(row['Trade_zone'], demand =row['gap_tz[MWh]'])%%00010%%00009%%00009################################## STEP C #########################%%00010%%00009%%00009# Assiging additional node for closing the export/import gap%%00010%%00009%%00009# calculation    %%00010%%00010%%00009%%00009G.add_node('Eq_exp_member', demand = -1*sum_imp)%%00010%%00009%%00009for index, row in gap_import.loc[(year)].iterrows():%%00010%%00009%%00009%%00009G.add_edge('Eq_exp_member', row['Trade_zone'], capacity=abs(sum_imp), weight=100000)%%00010%%00010%%00009%%00009G.add_node('Eq_imp_member', demand = -1*sum_exp)%%00010%%00009%%00009for index, row in gap_export.loc[(year)].iterrows():%%00010%%00009%%00009%%00009G.add_edge(row['Trade_zone'], 'Eq_imp_member', capacity=abs(sum_exp), weight=100000)%%00010%%00009%%00009%%00009# Virtual members' connection to ensure demand supply balance%%00010%%00009%%00009%%00009G.add_edge('Eq_exp_member', 'Eq_imp_member', capacity=min(abs(sum_exp), abs(sum_imp)), weight=1000)%%00010%%00010%%00009%%00009# flow calculation to find demand/supply in a directed Graph%%00010%%00009%%00009# source: https://networkx.github.io/documentation/stable/reference/...%%00010%%00009%%00009# algorithms/generated/networkx.algorithms.flow.network_simplex.html%%00010%%00009%%00009flowCost, flowDict = nx.network_simplex(G)%%00010%%00009%%00009#flowDict = nx.min_cost_flow(G)     %%00010%%00010%%00009%%00009bb=pd.DataFrame(flowDict)%%00010%%00009%%00009bb=bb.fillna(0)%%00010%%00009%%00009aa=bb.loc[e_imp, e_exp]%%00010%%00009%%00009ser=pd.Series(0, trz_list)%%00010%%00009%%00009ser_exported_gap = aa.sum()%%00010%%00009%%00009ser_imported_gap =-1*aa.sum(axis=1)   %%00010%%00009%%00009ser=ser.add(ser_exported_gap, fill_value=0)%%00010%%00009%%00009ser=ser.add(ser_imported_gap, fill_value=0)%%00010%%00010%%00009%%00009for it in ser.iteritems():%%00010%%00009%%00009%%00009sd_gap.loc[(year,it[0]), 'I/O_gap_reduce']=it[1]%%00010%%00010%%00009%%00009%%00009sd_gap['result_gap[TWh]']=(sd_gap['gap_tz[MWh]']+sd_gap['I/O_gap_reduce'])/1000000%%00010%%00010sd_gap_c_trz=pd.merge(with_trz, sd_gap[['I/O_gap_reduce','result_gap[TWh]']], on=['Years', 'Trade_zone'])%%00010%%00010output_table=sd_gap_c_trz"/>
<entry key="rowLimit" type="xint" value="1000"/>
<entry key="pythonVersionOption" type="xstring" value="PYTHON3"/>
<entry key="convertMissingToPython" type="xboolean" value="false"/>
<entry key="convertMissingFromPython" type="xboolean" value="false"/>
<entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
<entry key="sentinelValue" type="xint" value="0"/>
<entry key="chunkSize" type="xint" value="500000"/>
<entry key="python2Command" type="xstring" value=""/>
<entry key="python3Command" type="xstring" value=""/>
</config>
<config key="nodeAnnotation">
<entry key="text" type="xstring" value="calculation of trading zones' %%00013%%00010export/import  using Networlx %%00013%%00010module"/>
<entry key="bgcolor" type="xint" value="16777215"/>
<entry key="x-coordinate" type="xint" value="1933"/>
<entry key="y-coordinate" type="xint" value="279"/>
<entry key="width" type="xint" value="161"/>
<entry key="height" type="xint" value="45"/>
<entry key="alignment" type="xstring" value="CENTER"/>
<entry key="borderSize" type="xint" value="0"/>
<entry key="borderColor" type="xint" value="16777215"/>
<entry key="defFontSize" type="xint" value="9"/>
<entry key="annotation-version" type="xint" value="20151123"/>
<config key="styles"/>
</config>
<entry key="customDescription" type="xstring" isnull="true" value=""/>
<entry key="state" type="xstring" value="EXECUTED"/>
<entry key="factory" type="xstring" value="org.knime.python2.nodes.script2in1out.Python2Script2In1OutNodeFactory"/>
<entry key="node-name" type="xstring" value="Python Script (2⇒1)"/>
<entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
<entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python2.nodes"/>
<entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-bundle-version" type="xstring" value="3.7.2.v201904170931"/>
<entry key="node-feature-name" type="xstring" value="KNIME Python Integration"/>
<entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python2.feature.group"/>
<entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-feature-version" type="xstring" value="3.7.2.v201904170931"/>
<config key="factory_settings"/>
<entry key="name" type="xstring" value="Python Script (2⇒1)"/>
<entry key="hasContent" type="xboolean" value="true"/>
<entry key="isInactive" type="xboolean" value="false"/>
<config key="ports">
<config key="port_1">
<entry key="index" type="xint" value="1"/>
<entry key="port_spec_class" type="xstring" value="org.knime.core.data.DataTableSpec"/>
<entry key="port_object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
<entry key="port_object_summary" type="xstring" value="Rows: 203, Cols: 17"/>
<entry key="port_dir_location" type="xstring" value="port_1"/>
</config>
</config>
<config key="filestores">
<entry key="file_store_location" type="xstring" isnull="true" value=""/>
<entry key="file_store_id" type="xstring" value="957431b7-30f0-4ef0-822a-085bc7b7ff34"/>
</config>
</config>
